
Design patterns (easy to hard):

-   Factory Method
-   Abstract factory
-   Builder
-   Prototype
-   Singleton
-   Adapter
-   Bridge
-   Composite
-   Decorator
-   Facade
-   Flyweight
-   Proxy
-   Chain of Responsibility
-   Command
-   Interpreter
-   Iterator
-   Mediator
-   Memento
-   Observer
-   State
-   Strategy
-   Template method
-   Visitor
-   Null Object
-   Dependency Injection
-   Service Locator

Architectural patterns (easy to hard):

-   Model-View-Controller (MVC)
-   Model-View-Presenter (MVP)
-   Model-View-ViewModel (MVVM)
-   Command Query Responsibility Segregation (CQRS)
-   Event Sourcing
-   Microservices
-   Serverless
-   Event Driven Architecture (EDA)
-   Reactive Programming
-   Reactive Extensions (Rx)
-   Actors

Concurrency patterns (easy to hard):

-   Task Parallel Library (TPL)
-   Asynchronous Programming
-   Coroutines
-   Futures and Promises

Data access patterns (easy to hard):

-   Data Mapper
-   Active Record
-   Table Data Gateway
-   Row Data Gateway
-   Data Transfer Object (DTO)
-   Object-Relational Mapping (ORM)
-   Object Document Mapping (ODM)

Web API patterns (easy to hard):


<details>
 <summary>Web API patterns</summary>
-   GraphQL
-   REST
-   gRPC 

1.  REST (Representational State Transfer)
2.  CRUD (Create, Read, Update, Delete)
3.  HATEOAS (Hypermedia as the Engine of Application State)
4.  Pagination
5.  Versioning
6.  Filtering
7.  Sorting
8.  Validation
9.  Error handling
10.  Caching
11.  Compression
12.  Authentication and authorization
13.  Async and batch processing
14.  Streaming
15.  Server push notifications
16.  Media types negotiation
17.  Link header-based navigation
18.  CORS (Cross-Origin Resource Sharing)
19.  Content negotiation
20.  OAuth (Open Authorization)
21.  JWT (JSON Web Token)
22.  Basic authentication
23.  Digest authentication
24.  API Key
25.  Rate limiting 
26.  Load balancing
27.  Circuit breaker
28.  Health check
29.  OpenAPI (previously known as Swagger)
30.  GraphQL.
</details>

Messaging patterns (easy to hard):

-   Message Queue
-   Event Bus

Resilience patterns (easy to hard):

-   Circuit Breaker
-   Retry
-   Timeout

Memory patterns (easy to hard):

-   Object Pool
-   Flyweight

Algorithms (easy to hard):

-   Space-Time Tradeoff
-   Divide and Conquer
-   Dynamic Programming
-   Greedy Algorithm
-   Backtracking
-   Branch and Bound
-   Binary Search
-   Hashing
-   Sorting
-   Searching
-   Tree Traversal
-   Graph Traversal
-   Depth First Search (DFS)
-   Breadth First Search (BFS)
-   Minimum Spanning Tree (MST)
-   Shortest Path
-   Maximum Flow
-   Maximum Subarray
-   Maximum Subsequence
-   Kadane's Algorithm
-   Longest Common Subsequence (LCS)
-   Longest Increasing Subsequence (LIS)
-   Matrix Chain Multiplication
-   0-1 Knapsack
-   Coin Change
-   Activity Selection
-   Interval Scheduling
-   Job Sequencing with Deadlines.

Data structures (easy to hard):

-   Fizz Buzz
-   Palindrome
-   Reverse a String
-   Longest Palindromic Substring
-   Least Common Ancestor (LCA)
-   Binary Indexed Tree (BIT)
-   Segment Tree
-   Trie
-   HashMap
-   Linked List
-   Stack
-   Queue
-   Heap
-   Binary Search Tree (BST)
-   AVL Tree
-   Red-Black Tree
-   Splay Tree
-   Skip List
-   Union-Find
-   Disjoint Set
-   Topological Sort
-   Depth First Search (DFS)
-   Breadth First Search (BFS)
-   Dijkstra's Algorithm
-   Prim's Algorithm
-   Kruskal's Algorithm
-   Floyd-Warshall Algorithm
-   Bellman-Ford Algorithm
-   Maximum Bipartite Matching
-   Maximum Flow