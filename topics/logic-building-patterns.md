
Design patterns (easy to hard):

-   Factory Method
-   Abstract factory
-   Builder
-   Prototype
-   Singleton
-   Adapter
-   Bridge
-   Composite
-   Decorator
-   Facade
-   Flyweight
-   Proxy
-   Chain of Responsibility
-   Command
-   Interpreter
-   Iterator
-   Mediator
-   Memento
-   Observer
-   State
-   Strategy
-   Template method
-   Visitor
-   Null Object
-   Dependency Injection
-   Service Locator

Architectural patterns (easy to hard):

-   Model-View-Controller (MVC)
-   Model-View-Presenter (MVP)
-   Model-View-ViewModel (MVVM)
-   Command Query Responsibility Segregation (CQRS)
-   Event Sourcing
-   Microservices
-   Serverless
-   Event Driven Architecture (EDA)
-   Reactive Programming
-   Reactive Extensions (Rx)
-   Actors

Concurrency patterns (easy to hard):

-   Task Parallel Library (TPL)
-   Asynchronous Programming
-   Coroutines
-   Futures and Promises

Data access patterns (easy to hard):

-   Data Mapper
-   Active Record
-   Table Data Gateway
-   Row Data Gateway
-   Data Transfer Object (DTO)
-   Object-Relational Mapping (ORM)
-   Object Document Mapping (ODM)

Web API patterns (easy to hard):

-   GraphQL
-   REST
-   gRPC

Messaging patterns (easy to hard):

-   Message Queue
-   Event Bus

Resilience patterns (easy to hard):

-   Circuit Breaker
-   Retry
-   Timeout

Memory patterns (easy to hard):

-   Object Pool
-   Flyweight

Algorithms (easy to hard):

-   Space-Time Tradeoff
-   Divide and Conquer
-   Dynamic Programming
-   Greedy Algorithm
-   Backtracking
-   Branch and Bound
-   Binary Search
-   Hashing
-   Sorting
-   Searching
-   Tree Traversal
-   Graph Traversal
-   Depth First Search (DFS)
-   Breadth First Search (BFS)
-   Minimum Spanning Tree (MST)
-   Shortest Path
-   Maximum Flow
-   Maximum Subarray
-   Maximum Subsequence
-   Kadane's Algorithm
-   Longest Common Subsequence (LCS)
-   Longest Increasing Subsequence (LIS)
-   Matrix Chain Multiplication
-   0-1 Knapsack
-   Coin Change
-   Activity Selection
-   Interval Scheduling
-   Job Sequencing with Deadlines.

Data structures (easy to hard):

-   Fizz Buzz
-   Palindrome
-   Reverse a String
-   Longest Palindromic Substring
-   Least Common Ancestor (LCA)
-   Binary Indexed Tree (BIT)
-   Segment Tree
-   Trie
-   HashMap
-   Linked List
-   Stack
-   Queue
-   Heap
-   Binary Search Tree (BST)
-   AVL Tree
-   Red-Black Tree
-   Splay Tree
-   Skip List
-   Union-Find
-   Disjoint Set
-   Topological Sort
-   Depth First Search (DFS)
-   Breadth First Search (BFS)
-   Dijkstra's Algorithm
-   Prim's Algorithm
-   Kruskal's Algorithm
-   Floyd-Warshall Algorithm
-   Bellman-Ford Algorithm
-   Maximum Bipartite Matching
-   Maximum Flow